<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>事务管理</title>
    <link href="/2020/02/12/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    <url>/2020/02/12/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201107204053580.png" srcset="/img/loading.gif" alt="image-20201107204053580" style="zoom:67%;" /><p>在高并发场景下，若隔离没有控制得当，则可能产生：</p><p>脏读；不可重复读；幻读</p><p><strong>脏读：</strong></p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201107204144410.png" srcset="/img/loading.gif" alt="image-20201107204144410" style="zoom:50%;" /><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201107203810855.png" srcset="/img/loading.gif" alt="image-20201107203810855" style="zoom:67%;" /><p>开启事务（关闭自动提交事务）</p><p>提交事务</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal</title>
    <link href="/2020/02/05/ThreadLocal/"/>
    <url>/2020/02/05/ThreadLocal/</url>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal在JDBC-Connection场景中使用案列"><a href="#ThreadLocal在JDBC-Connection场景中使用案列" class="headerlink" title="ThreadLocal在JDBC Connection场景中使用案列"></a>ThreadLocal在JDBC Connection场景中使用案列</h2><p>使用ThreadLocal保存JDBC链接</p><p><strong>数据库连接工具类：</strong></p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201107195011934.png" srcset="/img/loading.gif" alt="image-20201107195011934" style="zoom:57%;" /><p>数据库链接的使用方式：</p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201107195147652.png" srcset="/img/loading.gif" alt="image-20201107195147652" style="zoom:57%;" /><p>这个数据库链接使用的方式在多线程下会报<strong>数据库连接关闭错误</strong>。因为这个连接在多线程下是共用的，可能线程1 close了，线程2还在用相同的连接。（<strong>疑问：</strong>DriverManager.getConnection返回的是同一个对象吗？否则多线程返回的应该互不相干啊？答：多线程出现的场景可能是这样的：假设有线程A与线程B，线程A执行完conn=DriverManager.getConnection后，线程B执行conn=DriverManager.getConnection后，又由于conn是static的，所以当线程A执行conn.close时，实际上是线程B的conn，因此，若此时线程B还在执行，则会报错）</p><p>使用ThreadLocal来保护连接（因为Connection是static变量才用ThreadLocal；又或者可以直接将Connection不设为static变量，这样就不会线程不安全）</p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201107201630166.png" srcset="/img/loading.gif" alt="image-20201107201630166" style="zoom:50%;" /><p>参考文献: 架构探险 从零开始写javaweb框架</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JMM</title>
    <link href="/2020/02/02/JMM/"/>
    <url>/2020/02/02/JMM/</url>
    
    <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>重排序与happens-before的关系是什么？</p><p>在重排序的基础上，JMM为了保证：</p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201101235436070.png" srcset="/img/loading.gif" alt="image-20201101235436070" style="zoom:67%;" /><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201101173100615.png" srcset="/img/loading.gif" alt="image-20201101173100615" style="zoom:67%;" /><p>​        编译器（代码重排序）与处理器（指令重排序）不会改变存在<strong>数据依赖关系</strong>的两个操作的执行顺序。</p><p>​        这里所说的<strong>数据依赖关系</strong>仅针对<strong>单个处理器</strong>中执行的指令序列和<strong>单个线程</strong>中执行的操作，<strong>不同处理器之间和不同线程</strong>之间的数据依赖关系<strong>不被编译器和处理器考虑</strong>。如：</p><p><code>sfafasfsdf</code></p><h2 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h2><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JAVA8</title>
    <link href="/2020/01/21/java8/"/>
    <url>/2020/01/21/java8/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA知识点"><a href="#JAVA知识点" class="headerlink" title="JAVA知识点"></a>JAVA知识点</h1><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201101155547162.png" srcset="/img/loading.gif" alt="image-20201101155547162" style="zoom:55%;" /><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201101155651257.png" srcset="/img/loading.gif" alt="image-20201101155651257" style="zoom:50%;" /></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>由上面两张图可知，Thread的构造函数的参数是函数式接口，调用方式可以是如下的任意一种：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">//注意，Runnable 的抽象函数的参数为空，因此传入的 getValue() setValue()函数的参数都为空</span>    <span class="hljs-keyword">new</span> Thread(() -&gt; setValue()).start();    <span class="hljs-keyword">new</span> Thread(Main::getValue).start();    <span class="hljs-comment">//注意 printAge(10) 这种形式的函数的传入</span>    <span class="hljs-keyword">new</span> Thread(() -&gt; printAge(<span class="hljs-number">10</span>)).start();&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> age = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">()</span> </span>&#123;    age = <span class="hljs-number">10</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(age);    <span class="hljs-keyword">return</span> age;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;    System.out.println(age);&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">happensBefore</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> b = a + <span class="hljs-number">1</span>;    System.out.println(b);&#125;</code></pre><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/147719155" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/147719155</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>重构</title>
    <link href="/2020/01/18/%E9%87%8D%E6%9E%84/"/>
    <url>/2020/01/18/%E9%87%8D%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="重构的目的"><a href="#重构的目的" class="headerlink" title="重构的目的"></a>重构的目的</h1><ul><li>使程序易于维护<ul><li>bug修复</li><li>特性增加</li></ul></li><li>若项目代码已经很凌乱或满是错误，则重构不如重写。</li></ul><h2 id="步骤一：构建一致性验证体系"><a href="#步骤一：构建一致性验证体系" class="headerlink" title="步骤一：构建一致性验证体系"></a>步骤一：构建一致性验证体系</h2><p>每次进行少量代码的重构，并在重构后进行一致性验证</p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201101113938245.png" srcset="/img/loading.gif" alt="image-20201101113938245" style="zoom:67%;" /><h2 id="步骤二：重构"><a href="#步骤二：重构" class="headerlink" title="步骤二：重构"></a>步骤二：重构</h2><ul><li>函数表达的是一个功能，而此功能应隶属于某个类。因此，应尽可能将函数放置本属于它的类中，即放对位置</li></ul><p>看到3.6节</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>开篇</title>
    <link href="/2020/01/12/%E5%BC%80%E7%AF%87/"/>
    <url>/2020/01/12/%E5%BC%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="开篇——过往知识的总结"><a href="#开篇——过往知识的总结" class="headerlink" title="开篇——过往知识的总结"></a>开篇——过往知识的总结</h1><h2 id="为什么要对之前的知识进行总结？"><a href="#为什么要对之前的知识进行总结？" class="headerlink" title="为什么要对之前的知识进行总结？"></a>为什么要对之前的知识进行总结？</h2><p>​        目前很多笔记较为零散。<em>在形式上</em>，笔记内容散落于onenote 有道笔记 线下笔记簿 手机笔记簿 等各处；<em>在内容上</em>，许多同类知识点未能从点串连成线，形成更为系统的知识框架。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h2><h3 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h3><ul><li>重构</li><li>设计模式</li></ul><h2 id="思维"><a href="#思维" class="headerlink" title="思维"></a>思维</h2><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
