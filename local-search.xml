<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据库/数据库实现</title>
    <link href="/2021/04/23/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/04/23/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库实现"><a href="#数据库实现" class="headerlink" title="数据库实现"></a>数据库实现</h1><p><strong>存储：</strong></p><p>​    一个page可以存储一张表的schema（即page存储这个表有几列，每一列的属性信息等等）；一个page还可以存储tuple值（即多行的值），但这种情况下，若包含schema的page丢失，则其他所有在这个schema下的tuple值翻译不了了。所以，有的系统在一个page中即存储schema也存储对应的tuple值。</p><p>![image-20210423161456459](/Users/weizihan/Library/Application Support/typora-user-images/image-20210423161456459.png)</p><p>​            dirty flag 表示这个页是否是脏页（我的理解是：即这个页在内存中被修改了，与磁盘上的不一致了）</p><p>​            Ref Counter 引用计数，则这个页被多少个线程使用</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Lock与Latch的区别</p><p>![image-20210423162652336](/Users/weizihan/Library/Application Support/typora-user-images/image-20210423162652336.png)</p><p>![image-20210423163152992](/Users/weizihan/Library/Application Support/typora-user-images/image-20210423163152992.png)</p><p>​        OS也会进行数据的读写，但是用数据库是因为：数据库能够知道数据的语义。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>微服务/seata</title>
    <link href="/2021/03/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1/seata/"/>
    <url>/2021/03/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1/seata/</url>
    
    <content type="html"><![CDATA[<p>seata</p><pre><code class="hljs 目前分布式事务解决的方案主要有对业务无入侵和有入侵的方案，无入侵方案主要有基于数据库">目前分布式事务解决的方案主要有对业务无入侵和有入侵的方案，无入侵方案主要有基于数据库 XA 协议的两段式提交（2PC）方案，它的优点是对业务代码无入侵，但是它的缺点也是很明显：必须要求数据库对 XA 协议的支持，且由于 XA 协议自身的特点，它会造成事务资源长时间得不到释放，锁定周期长，而且在应用层上面无法干预，因此它性能很差，它的存在相当于七伤拳那样“伤人七分，损己三分”，因此在互联网项目中并不是很流行这种解决方案。为了这个弥补这种方案带来性能低的问题，大佬们又想出了很多种方案来解决，但这无一例外都需要通过在应用层做手脚，即入侵业务的方式，比如很出名的 TCC 方案，基于 TCC 也有很多成熟的框架，如 ByteTCC、tcc-transaction 等。以及基于可靠消息的最终一致性来实现，如 RocketMQ 的事务消息。入侵代码的方案是基于现有情形“迫不得已”才推出的解决方案，实际上它们实现起来非常不优雅，一个事务的调用通常伴随而来的是对该事务接口增加一系列的反向操作，比如 TCC 三段式提交，提交逻辑必然伴随着回滚的逻辑，这样的代码会使得项目非常臃肿，维护成本高。</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IoTDB/Wildcard</title>
    <link href="/2021/03/03/IoTDB/Wildcard/"/>
    <url>/2021/03/03/IoTDB/Wildcard/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IoTDB/通配符</title>
    <link href="/2021/03/03/IoTDB/%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
    <url>/2021/03/03/IoTDB/%E9%80%9A%E9%85%8D%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="How-to-use-the-wildcard-to-match-one-or-more-layers-of-nodes-in-the-time-series-path"><a href="#How-to-use-the-wildcard-to-match-one-or-more-layers-of-nodes-in-the-time-series-path" class="headerlink" title="How to use the wildcard * to match one or more layers of nodes in the time series path?"></a>How to use the wildcard * to match one or more layers of nodes in the time series path?</h3><p>（The initial discussion is at <a href="https://issues.apache.org/jira/browse/IOTDB-1160）" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/IOTDB-1160）</a></p><h4 id="First-Solution"><a href="#First-Solution" class="headerlink" title="First Solution:"></a>First Solution:</h4><p>“*” matches just one layer and “<strong>“ matches one or more layers. As a result, the SQL statement “select * from root” have to be converted into “select \</strong> from root”. It seems a little bit disappointing.</p><h4 id="Second-Solution"><a href="#Second-Solution" class="headerlink" title="Second Solution:"></a><strong>Second Solution:</strong></h4><p>“*“ matches one or more layers by default. And we can put something like “1 layer”(layer is the keyword) in the SQL statement to strengthen the semantics to match just one layer. More, “2 layers” to match just two layers and so on. This solution can be more scalable, I think.</p><h5 id="Does-anyone-have-any-idea-about-this-Welcome-to-discuss"><a href="#Does-anyone-have-any-idea-about-this-Welcome-to-discuss" class="headerlink" title="Does anyone have any idea about this? Welcome to discuss."></a>Does anyone have any idea about this? Welcome to discuss.</h5>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IoTDB/cluster启动配置</title>
    <link href="/2021/02/04/IoTDB/cluster%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/02/04/IoTDB/cluster%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>1.打包命令 <code>mvn clean package -pl cluster -am -DskipTests</code></p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 第一步 (注意以下路径在 Windows MinGW 中并不适用)</span>mvn clean package -pl cluster -am -Dmaven.test.skip=trueNODE_NUM=3export CLUSTER_JAR_PATH=/Users/weizihan/wzh/coding/GitRepository/iotdb_cluster_learn_jar/targetCLUSTER_SNAPSHOT_NAME=$(find $CLUSTER_JAR_PATH -name "cluster-*-SNAPSHOT" | sed 's#.*/##')CLUSTER_SNAPSHOT_NAME_SECOND="$CLUSTER_SNAPSHOT_NAME"2CLUSTER_SNAPSHOT_NAME_THIRD="$CLUSTER_SNAPSHOT_NAME"3RPC_PORT=6667JMX_PORT=31999for((i=1;i&lt;=10;i++));  do   echo i;  done  cp -rf $CLUSTER_JAR_PATH/$CLUSTER_SNAPSHOT_NAME $CLUSTER_JAR_PATH/$CLUSTER_SNAPSHOT_NAME_SECONDcp -rf $CLUSTER_JAR_PATH/$CLUSTER_SNAPSHOT_NAME $CLUSTER_JAR_PATH/$CLUSTER_SNAPSHOT_NAME_THIRDsed -i -e 's/6667/6668/g' $CLUSTER_JAR_PATH/$CLUSTER_SNAPSHOT_NAME_SECOND/conf/iotdb-engine.propertiessed -i -e 's/6667/6669/g' $CLUSTER_JAR_PATH/$CLUSTER_SNAPSHOT_NAME_THIRD/conf/iotdb-engine.properties<span class="hljs-meta">#</span><span class="bash"> 第二步: Unix/OS X/Windows (git bash or WSL)</span>sed -i -e 's/31999/32000/g' $CLUSTER_JAR_PATH/$CLUSTER_SNAPSHOT_NAME_SECOND/conf/iotdb-env.shsed -i -e 's/31999/32001/g' $CLUSTER_JAR_PATH/$CLUSTER_SNAPSHOT_NAME_THIRD/conf/iotdb-env.shchmod -R 777 $CLUSTER_JAR_PATH/nohup $CLUSTER_JAR_PATH/$CLUSTER_SNAPSHOT_NAME/sbin/start-node.sh &gt;/dev/null 2&gt;&amp;1 &amp;nohup $CLUSTER_JAR_PATH/$CLUSTER_SNAPSHOT_NAME_SECOND/sbin/start-node.sh -internal_meta_port 9005 -internal_data_port 40012 -cluster_rpc_port 55561 &gt;/dev/null 2&gt;&amp;1 &amp;nohup $CLUSTER_JAR_PATH/$CLUSTER_SNAPSHOT_NAME_THIRD/sbin/start-node.sh -internal_meta_port 9007 -internal_data_port 40014 -cluster_rpc_port 55562 &gt;/dev/null 2&gt;&amp;1 &amp;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IoTDB/Cluster架构</title>
    <link href="/2021/02/04/IoTDB/Cluster%E6%9E%B6%E6%9E%84/"/>
    <url>/2021/02/04/IoTDB/Cluster%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>1.复习从github上下载的，在公司电脑上的raft的分布式代码</p><p><strong>分布式IoTDB服务启动：</strong>（start模式）</p><ol><li>创建节点实例（即创建MetaClusterServer）</li><li>资源以及配置校验</li></ol><h4 id="MetaClusterServer"><a href="#MetaClusterServer" class="headerlink" title="MetaClusterServer"></a>MetaClusterServer</h4><ol><li>receives MetaGroup RPCs from internal_meta_port</li><li>MetaClusterServer checks its configuration with other nodes, ensuring that at least over half of the nodes have consistent configuration</li><li>initializes the underlying IoTDB</li><li>creates a MetaMember</li><li>creates a Coordinator</li></ol><h4 id="MetaMember"><a href="#MetaMember" class="headerlink" title="MetaMember"></a>MetaMember</h4><ol><li>initialized as an ELECTOR</li><li>handles MetaGroup RPCs</li><li>manages a partition table;</li><li>creates its MetaHeartbeatThread;</li></ol><h4 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a>Coordinator</h4><ol><li>a coordinator for non-query;</li><li></li></ol><ol><li>The leader of MetaGroup sends a heartbeat to MetaClusterServer;</li><li>MetaClusterServer lets MetaMember handle the heartbeat;</li></ol><p><strong>对于节点的操作有两种模式：</strong></p><p>add：</p><ol><li>创建节点实例（即创建MetaClusterServer）</li><li>各种线程启动</li></ol><p>remove：</p><ol><li>根据ip:port找到对应程序，并发送停止信号</li><li>根据配置文件中配置的多台服务器信息，找到其他节点</li><li>告知其他节点，将此节点相关的信息移除。</li></ol><p><strong>完善：</strong>考虑异常处理</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IoTDB/Untitled</title>
    <link href="/2021/02/03/IoTDB/Untitled/"/>
    <url>/2021/02/03/IoTDB/Untitled/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs ````"></code></pre><p>public MeasurementMNode[] getMNodes(PartialPath deviceId, String[] measurements)<br>    throws MetadataException {<br>  MNode deviceNode = getNodeByPath(deviceId);<br>  MeasurementMNode[] mNodes = new MeasurementMNode[measurements.length];<br>  for (int i = 0; i &lt; mNodes.length; i++) {<br>    MNode child = deviceNode.getChild(measurements[i]);<br>    if (child instanceof MeasurementMNode) {<br>      mNodes[i] = ((MeasurementMNode) child);<br>    } else {<br>      mNodes[i] = null;<br>    }</p><pre><code>if (mNodes[i] == null &amp;&amp; !IoTDBDescriptor.getInstance().getConfig().isEnablePartialInsert()) {  throw new MetadataException(measurements[i] + &quot; does not exist in &quot; + deviceId);}</code></pre><p>  }<br>  return mNodes;<br>}<br>```</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IoTDB/Design on creating a time series</title>
    <link href="/2021/01/29/IoTDB/Design%20on%20creating%20a%20time%20series/"/>
    <url>/2021/01/29/IoTDB/Design%20on%20creating%20a%20time%20series/</url>
    
    <content type="html"><![CDATA[<h3 id="Design-on-creating-a-time-series-that-is-a-prefix-path-of-an-existing-time-series"><a href="#Design-on-creating-a-time-series-that-is-a-prefix-path-of-an-existing-time-series" class="headerlink" title="Design on creating a time series that is a prefix path of an existing time series"></a>Design on creating a time series that is a prefix path of an existing time series</h3><h4 id="一-Background"><a href="#一-Background" class="headerlink" title="一.Background"></a>一.Background</h4><p>​    Up to date, it fails to create a time series that is a prefix path of an existing time series in IoTDB system.</p><p>​    e.g.</p><p>​    （1）create time series by “create” statement：（Here’s execution order）</p><p>​            <code>create timeseries root.a.b.c.d with datatype=float</code></p><p>​            <code>create timeseries root.a.b.c with datatype=float</code></p><p>​            Creating time series root.a.b.c fails.</p><p>​    （2）create time series by “insert” statement：（Here’s execution order）</p><p>​            <code>insert into root.a.b.c(timestamp, d) values(1, 1.0)</code></p><p>​            <code>insert into root.a.b(timestamp, c) values(1, 1.0)</code></p><p>​            Creating time series root.a.b.c fails.</p><h4 id="二-Design"><a href="#二-Design" class="headerlink" title="二.Design"></a>二.Design</h4><p>1.Currently, there’re three types to represent nodes on a MTree in the system：MNode, StorageGroupMNode, MeasurementMNode.</p><p>​    StorageGroupMNode and MeasurementMNode are inherited from MNode and respectively represent the storage node and measurement node. The remaining nodes (including the root node) are directly implemented by MNode.</p><p>2.After the modification, the prefix path of an existing time series can be converted into a time series in the following ways:（given time series root.a.b.c.d already exists）</p><p>​        (1)<code>create timeseries root.a.b.c with datatype=float</code> </p><p>​        (2)<code>insert into root.a.b(timestamp, c) values(100, 1.0)</code></p><p>2.1Procedures of creating time series by “create” statement</p><p>​    （1）Firstly, determine whether “c” is already a MeasurementMNode. If it is, throw the PathAlreadyExistException;（new）</p><p>​    （2）If it isn’t, create a MeasurementMNode of c, and replace c(MNode type) in root.a.b.c.d with c(MeasurementMNode type);（new）</p><p>​    （3）As the information to be restored after restarting the system, this plan of creating time series will be serialized into the meta log;（this function already exists in the system, nothing will be modified.）</p><p>2.2Procedures of creating time series by “insert” statement</p><p>​    （1）First of all, determine whether “c” is already a MeasurementMNode. If so, return directly.</p><p>​    （2）If not, create c as a MeasurementMNode, and replace c (MNode type) in the root.a.b.c.d time series with c (MeasurementMNode); （new）</p><p>​    （3）As the information to be restored after restarting the system, this plan of creating time series will be serialized into the meta log;（this function already exists in the system, nothing will be modified.）</p><p>​    To sum up, the difference between 2.1 and 2.2 is only the step (1), and step (2) and step (3) in 2.1 and 2.2 will be extract into one common method called org.apache.iotdb.db.metadata.MTree#createTimeseries.</p><h5 id="3-Test"><a href="#3-Test" class="headerlink" title="3.Test"></a>3.Test</h5><p>（1）Test whether it will be successful to create time series that is the prefix path of an existing time series by the two ways.</p><p>（2）After creating that type of time series, restart the system to see if the created time series still exist and the system is not abnormal.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IoTDB/关于将已存在时间序列的前缀序列创建为时间序列的设计</title>
    <link href="/2021/01/29/IoTDB/%E5%85%B3%E4%BA%8E%E5%B0%86%E5%B7%B2%E5%AD%98%E5%9C%A8%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9A%84%E5%89%8D%E7%BC%80%E5%BA%8F%E5%88%97%E5%88%9B%E5%BB%BA%E4%B8%BA%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/2021/01/29/IoTDB/%E5%85%B3%E4%BA%8E%E5%B0%86%E5%B7%B2%E5%AD%98%E5%9C%A8%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9A%84%E5%89%8D%E7%BC%80%E5%BA%8F%E5%88%97%E5%88%9B%E5%BB%BA%E4%B8%BA%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="关于将已存在时间序列的前缀序列创建为时间序列的设计"><a href="#关于将已存在时间序列的前缀序列创建为时间序列的设计" class="headerlink" title="关于将已存在时间序列的前缀序列创建为时间序列的设计"></a>关于将已存在时间序列的前缀序列创建为时间序列的设计</h3><h4 id="一-背景"><a href="#一-背景" class="headerlink" title="一.背景"></a>一.背景</h4><p>​    目前，在IoTDB系统中若将已存在时间序列的前缀序列创建为时间序列，则会创建失败。</p><p>​    例子: </p><p>​    （1）通过create语句创建时间序列：（语句执行顺序如下）</p><p>​            <code>create timeseries root.a.b.c.d with datatype=float</code></p><p>​            <code>create timeseries root.a.b.c with datatype=float</code></p><p>​            则时间序列root.a.b.c将创建失败</p><p>​    （2）通过insert语句创建时间序列：（语句执行顺序如下）</p><p>​            <code>insert into root.a.b.c(timestamp, d) values(1, 1.0)</code></p><p>​            <code>insert into root.a.b(timestamp, c) values(1, 1.0)</code></p><p>​            则往时间序列root.a.b.c中插入数据失败（因为时间序列root.a.b.c不存在，需要先创建root.a.b.c，而创建该时间序列将会失败）</p><h4 id="二-设计"><a href="#二-设计" class="headerlink" title="二.设计"></a>二.设计</h4><h5 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h5><p>​    目前系统中表示路径节点的类型有三种，分别是MNode, StorageGroupMNode, MeasurementMNode</p><p>​    StorageGroupMNode, MeasurementMNode 继承自 MNode 分别表示 存储节点 测量节点，剩余的节点（包括root节点）由MNode直接实现。</p><h5 id="2-修改思路"><a href="#2-修改思路" class="headerlink" title="2.修改思路"></a>2.修改思路</h5><p>2.1修改后将支持通过以下方式将已存在时间序列的前缀路径修改为时间序列：</p><p>​        前提：时间序列root.a.b.c.d已存在</p><p>​        方式1：</p><p>​        <code>create timeseries root.a.b.c with datatype=float</code> </p><p>​        方式2：</p><p>​        <code>insert into root.a.b(timestamp, c) values(100, 1.0)</code></p><p>2.2</p><p>​    1.方式1创建时间序列的过程:</p><p>​    （1）首先，先判断c是否已经是MeasurementMNode，若是，则抛出 PathAlreadyExistException 异常；（新增）</p><p>​    （2）若不是，则创建c为MeasurementMNode，且创建完后将 root.a.b.c.d 时间序列中的c（MNode类型）替换为c（MeasurementMNode）;（新增）</p><p>​    （3）将该创建时间序列的plan序列化到meta log中，作为系统重启后恢复的信息。（该功能系统中已有，不用修改）</p><p>​    2.方式2创建时间序列的过程:</p><p>​    （1）首先，先判断c是否已经是 MeasurementMNode ，若是，则直接返回；</p><p>​    （2）若不是，则创建c为MeasurementMNode ，且创建完后将root.a.b.c.d时间序列中的c（MNode类型），替换为c（MeasurementMNode）；（新增）</p><p>​    （3）将该创建时间序列的plan序列化到meta log中，作为系统重启后恢复的信息。（该功能系统中已有，不用修改）</p><p>​    <strong>其中</strong>（2）（3）的过程已经抽象为同一个方法，即org.apache.iotdb.db.metadata.MTree#createTimeseries</p><h5 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h5><p>（1）测试是否能通过以上描述的两种方式创建时间序列；</p><p>（2）创建完对应时间序列后，重启系统，看是否创建的序列还存在，且系统未出现异常。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IoTDB/修改元数据的设计 (copy)</title>
    <link href="/2021/01/29/IoTDB/%E4%BF%AE%E6%94%B9%E5%85%83%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AE%BE%E8%AE%A1%20(copy)/"/>
    <url>/2021/01/29/IoTDB/%E4%BF%AE%E6%94%B9%E5%85%83%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AE%BE%E8%AE%A1%20(copy)/</url>
    
    <content type="html"><![CDATA[<p>The design on converting prefix path of an existing time series into time series</p><p>Background</p><p>将系统中已存在时间序列的前缀路径修改为时间序列的设计</p><p>背景</p><p>目前系统中表示元数据节点的类型有三种，分别是MNode, StorageGroupMNode, MeasurementMNode</p><p>StorageGroupMNode, MeasurementMNode 继承自 MNode 分别表示 存储节点 测量节点，剩余的节点（包括root节点）由MNode直接实现。</p><p>目前，在系统中若创建已存在时间序列的前缀修改为时间序列，则会不成功。</p><p>设计</p><p>支持通过两种方式将已存在时间序列的前缀修改为时间序列。</p><p>方式1：</p><p>前提：时间序列root.a.b.c.d.e已存在</p><pre><code class="hljs create">方式2：&#96;&#96;&#96;insert into root.a.b.c(timestamp, d) values(100, &#39;haha&#39;)</code></pre><p>方式1:（77c9e7290a78ad81e5e861860aba6af75ce773dd）</p><p>（1）首先，先判断d是否已经是 MeasurementMNode ，若是，则抛出 PathAlreadyExistException 异常；（新增）</p><p>若不是，则创建 MeasurementMNode ，且创建完后将 root.a.b.c.d.e 时间序列中的d（MNode类型），替换为d（MeasurementMNode）。（新增）</p><p>（2）将该创建时间序列的plan序列化到meta log中（该功能系统中已有，不用修改），作为系统重启后恢复的信息。</p><p>方式2:（e18d884677a0ba4e00c40721b169b90d7ff03a6e）</p><p>org.apache.iotdb.db.metadata.MManager#getMeasurementMNode</p><p>（1）首先，先判断d是否已经是 MeasurementMNode ，若是，则直接返回；</p><p>否则， 创建 MeasurementMNode ，且创建完后将 root.a.b.c.d.e 时间序列中的d（MNode类型），替换为d（MeasurementMNode）。（新增）</p><p>（2）将替换的信息写入meta log中，作为系统重启后恢复的信息（新增）</p><p>（3）基于步骤(2)，需要新增 AlterTimeSeriesBasicInfoPlan 方法，其中主要为将修改信息序列化入磁盘以及从磁盘中反序列化信息，恢复元数据的在内存中的信息</p><p><strong>注意</strong>：创建完字序列后，重启系统，看是否创建的序列还存在。</p><p><strong>删除前缀序列还有问题</strong></p><p>删除前缀时间序列的时候，要判断：</p><p>1）该节点是否是measure，不是，则抛出异常信息</p><p>2）若是，该判断节点是否有孩子节点，若无，则直接将该节点删除</p><p>2）若有，则还原成mnode</p><p>下一步打算</p><p>Future Work</p><p>引入InternalMNode 避免直接创建MNode</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>性能调优经验案例</title>
    <link href="/2020/11/28/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%BB%8F%E9%AA%8C%E6%A1%88%E4%BE%8B/"/>
    <url>/2020/11/28/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%BB%8F%E9%AA%8C%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="性能优化三步骤"><a href="#性能优化三步骤" class="headerlink" title="性能优化三步骤"></a>性能优化三步骤</h1><ol><li>性能监控</li><li>性能分析</li><li>性能调优</li></ol><h1 id="一-性能监控"><a href="#一-性能监控" class="headerlink" title="一.性能监控"></a>一.性能监控</h1><h2 id="1-操作系统级别监控数据"><a href="#1-操作系统级别监控数据" class="headerlink" title="1.操作系统级别监控数据"></a>1.操作系统级别监控数据</h2><h3 id="1）CPU"><a href="#1）CPU" class="headerlink" title="1）CPU"></a>1）CPU</h3><h4 id="（1）CPU使用率"><a href="#（1）CPU使用率" class="headerlink" title="（1）CPU使用率"></a>（1）CPU使用率</h4><ul><li><p>用户态CPU使用率</p></li><li><p>系统态CPU使用率</p><p><strong>原则：</strong>尽可能将分配得到的CPU周期都用来计算。</p></li></ul><p>​    系统态CPU使用率高意味着有资源竞争或正在进行I/O。最理想的情况下应该使系统态CPU使用率降为0%，即尽可能降低系统态CPU使用率。这样将有更多的CPU周期用于应用程序的计算。</p><p>查看CPU使用率与空闲率的方式：<strong>vmstat</strong></p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201126194307632.png" srcset="/img/loading.gif" alt="image-20201126194307632" style="zoom:80%;" /><p>​        其中us与sy分别是用户态CPU使用率与系统态CPU使用率；id是空闲率或CPU可用率us+sy+id应该为100。</p><h4 id="（2）CPU调度程序运行队列"><a href="#（2）CPU调度程序运行队列" class="headerlink" title="（2）CPU调度程序运行队列"></a><strong>（2）CPU调度程序运行队列</strong></h4><p>​        运行队列即为已准备好运行的轻量级进程。其数量若过长，则表明可能已经饱和，当运行队列长度达到虚拟处理器的4倍或更多时，系统的响应速度就会非常迟缓了。</p><p>​        原则：若在很长一段时间，运行队列的个数达到虚拟处理器的个数的3倍以上，就需要引起重视了。</p><p>​        解决方式：1）增加CPU；2）优化算法和数据结构</p><p>​        虚拟处理器的个数就是系统硬件线程的个数，也是java的Runtime.availableProcessors()的返回值</p><p>​        vmstat输出的第一列是运行队列的长度，即轻量级进程的实际数量</p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201130102037911.png" srcset="/img/loading.gif" alt="image-20201130102037911" style="zoom:80%;" /><h4 id="（3）监控锁竞争"><a href="#（3）监控锁竞争" class="headerlink" title="（3）监控锁竞争"></a>（3）监控锁竞争</h4><p>​        线程通过忙循环自旋尝试获得锁，如果若干次忙循环自旋后仍没有成功，则挂起该线程，等待被唤醒再次尝试获取该锁。</p><p>​        <strong>注意：</strong>对于锁占用时间短的应用来说自旋锁改善性能的效果非常好，但对于占用时间长的锁，则会加重性能损失。</p><p>​        <strong>挂起与唤醒</strong>会导致操作系统<strong>让步式上下文切换</strong>。因此若出现大量的让步式上下文切换，则很有可能由于锁竞争严重导致。让步式上下文切换耗费的时钟周期代价非常高，通常高达80,000个时钟周期。</p><p>​        </p><p>​    <strong>什么命令可以观察抢占式上下文切换与让步式上下文切换的次数？</strong></p><p>​        pidstat -w输出中的cswch/s是所有虚拟处理器的让步式上下文切换；报告的是每秒而不是每个测量间隔的让步式上下文切换。</p><p>让步式上下文切换数乘以80,000再除以CPU每秒的时钟周期，可以得到让步式上下文切换所消耗的CPU时钟周期百分比。</p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201130150436706.png" srcset="/img/loading.gif" alt="image-20201130150436706" style="zoom:80%;" /><p>​        <strong>抢占式上下文切换率高表明</strong>：准备运行的线程数多于可用虚拟处理器。用vmstat命令也能看到很多的运行队列 很高的CPU使用率 很大的迁移数。</p><h4 id="（4）监控线程迁移"><a href="#（4）监控线程迁移" class="headerlink" title="（4）监控线程迁移"></a><strong>（4）监控线程迁移</strong></h4><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201130120131795.png" srcset="/img/loading.gif" alt="image-20201130120131795" style="zoom:80%;" /><h3 id="2）内存使用率"><a href="#2）内存使用率" class="headerlink" title="2）内存使用率"></a>2）内存使用率</h3><p>​        内存相关信息：页面调度或页面交换(借由swap分区的交换会极大的影响性能) 加锁 线程调度中的让步式与抢占式上下文切换</p><p>​        使用vmstat的free列 si列 so列监控页面交换，分别表示可用的空闲内存 内存页面换入的量 内存页面换出的量</p><p>​    <img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201130103126006.png" srcset="/img/loading.gif" alt="image-20201130103126006" style="zoom:50%;" /></p><p>![image-20201130103144093](/Users/weizihan/Library/Application Support/typora-user-images/image-20201130103144093.png)</p><p>​        观察上图，可得到如下的<strong>数据模式</strong>：</p><h3 id="3）IO使用率"><a href="#3）IO使用率" class="headerlink" title="3）IO使用率"></a><strong>3）IO使用率</strong></h3><h4 id="（1）网络IO使用率"><a href="#（1）网络IO使用率" class="headerlink" title="（1）网络IO使用率"></a>（1）网络IO使用率</h4><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201130121413455.png" srcset="/img/loading.gif" alt="image-20201130121413455" style="zoom:80%;" /><h4 id="（2）磁盘IO使用率"><a href="#（2）磁盘IO使用率" class="headerlink" title="（2）磁盘IO使用率"></a>（2）磁盘IO使用率</h4><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201130121712184.png" srcset="/img/loading.gif" alt="image-20201130121712184" style="zoom:80%;" /><p>​        判断在读或写哪个文件 磁盘活动是由哪个应用产生是监控磁盘IO使用率的难点。</p><h3 id="如何长时间监控应用？"><a href="#如何长时间监控应用？" class="headerlink" title="如何长时间监控应用？"></a>如何长时间监控应用？</h3><p>​    使用sar收集性能数据</p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201130122213561.png" srcset="/img/loading.gif" alt="image-20201130122213561" style="zoom:80%;" /><h2 id="2-JVM级别监控数据"><a href="#2-JVM级别监控数据" class="headerlink" title="2.JVM级别监控数据"></a>2.JVM级别监控数据</h2><p>重要的性能监控的数据：</p><ul><li>jvm堆的大小：新生代 老年代 永久代大小</li><li>GC时间与频率：Minor GC Full GC的时间与频率</li><li></li></ul><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201129134326410.png" srcset="/img/loading.gif" alt="image-20201129134326410" style="zoom:50%;" /><ul><li><p>监控锁竞争</p><p>jstack查找锁竞争</p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201129141651940.png" srcset="/img/loading.gif" alt="image-20201129141651940" style="zoom:80%;" /><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201129141711967.png" srcset="/img/loading.gif" alt="image-20201129141711967" style="zoom:80%;" /></li></ul><p>JProfile 与 Jvisualvm</p><h1 id="二-性能分析"><a href="#二-性能分析" class="headerlink" title="二.性能分析"></a>二.性能分析</h1><h4 id="操作系统监控数据分析"><a href="#操作系统监控数据分析" class="headerlink" title="操作系统监控数据分析"></a>操作系统监控数据分析</h4><h4 id="JVM分析"><a href="#JVM分析" class="headerlink" title="JVM分析"></a>JVM分析</h4><ul><li><p>方法分析</p><ul><li><p>方法执行时间的信息</p><p>notion: 方法的包含时间与独占时间</p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201128200725847.png" srcset="/img/loading.gif" alt="image-20201128200725847" style="zoom:80%;" /></li></ul></li></ul><pre><code>&lt;img src=&quot;/Users/weizihan/Library/Application Support/typora-user-images/image-20201128200755096.png&quot; alt=&quot;image-20201128200755096&quot; style=&quot;zoom:80%;&quot; /&gt;tool:</code></pre><ul><li><p>Java堆内存分析</p><p>逻辑空间的划分：</p><p>Eden:几乎新建的java对象都在这个内存池</p><p>Survivor:这个内存池包含那些至少经历过一次Eden垃圾收集而仍然存活的对象</p><p>Old或Tenured:这个内存池包含那些超过垃圾回收年龄阈值而仍然存活的对象</p><p>Permanent:这个内存池包含所有的JVM元数据，如Class和Method对象</p><p>Code Cache:这个内存空间存储经过JIT编译器编译后的代码</p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201129140110592.png" srcset="/img/loading.gif" alt="image-20201129140110592" style="zoom:80%;" /></li></ul><p>所使用工具：JProfile <strong>Oracle® Solaris Studio 12.4: Performance Analyzer</strong></p><p>如何发现锁竞争的现象？</p><h1 id="三-性能优化"><a href="#三-性能优化" class="headerlink" title="三.性能优化"></a>三.性能优化</h1><h4 id="应用层优化"><a href="#应用层优化" class="headerlink" title="应用层优化"></a>应用层优化</h4><ul><li><p>内核态(系统)CPU使用优化</p></li><li><p>更高效的算法</p></li><li><p>减少锁竞争（如减少竞争的频率以及缩短锁持有的时长）</p></li><li><p>用更少的CPU指令实现算法：即实现一个算法需要的CPU指令越少，则所需要的时钟周期也就越少。</p></li><li><p>并行优化</p></li></ul><ol><li><p>内核态(系统)CPU使用优化</p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201129145330035.png" srcset="/img/loading.gif" alt="image-20201129145330035" style="zoom:50%;" /></li></ol><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201129145420290.png" srcset="/img/loading.gif" alt="image-20201129145420290" style="zoom:67%;" /><p>  2.锁竞争优化</p>  <img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201129145750087.png" srcset="/img/loading.gif" alt="image-20201129145750087" style="zoom:80%;" /><ol start="3"><li>volatile的使用</li></ol><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201129150627858.png" srcset="/img/loading.gif" alt="image-20201129150627858" style="zoom:80%;" /><h4 id="jvm优化（HotSpot）"><a href="#jvm优化（HotSpot）" class="headerlink" title="jvm优化（HotSpot）"></a>jvm优化（HotSpot）</h4><p>系统需求：吞吐量 响应时间 内存消耗 可管理性等</p><p>1.对系统需求进行优先级划分</p><p>​    吞吐量》响应时间〉内存消耗》可管理性</p><p>2.client模式与server模式</p><p>3.垃圾收集器的选择</p><p>​    Serial CMS G1 ZHC等</p><p>​    <strong>GC的调优基础</strong></p><p>​        指标：吞吐量 响应时间 内存消耗</p><p>​        原则：</p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201129162127612.png" srcset="/img/loading.gif" alt="image-20201129162127612" style="zoom:80%;" /><p>-Xmx和-Xms命令行参数</p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201129162508598.png" srcset="/img/loading.gif" alt="image-20201129162508598" style="zoom:80%;" /><p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201129162755881.png" srcset="/img/loading.gif" alt="image-20201129162755881" style="zoom: 80%;" />![image-20201129162810538](/Users/weizihan/Library/Application Support/typora-user-images/image-20201129162810538.png)</p><p>![image-20201129162810538](/Users/weizihan/Library/Application Support/typora-user-images/image-20201129162810538.png)</p><h4 id="操作系统优化"><a href="#操作系统优化" class="headerlink" title="操作系统优化"></a>操作系统优化</h4><p>​    一般优化还不到这一步</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201129150009617.png" srcset="/img/loading.gif" alt="image-20201129150009617" style="zoom:80%;" /></h2><p><strong>概念：</strong></p><p>系统态CPU时间：方法运行在内核态时所占的时间</p><p>用户态CPU时间：方法运行在非内核态时所占的时间</p><p>让步式上下文切换：执行线程主动释放CPU</p><p>抢占式上下文切换：时间片用尽而被迫放弃CPU或被其他优先级更高的线程抢占</p><p>上下文切换：上下文即一个时刻cpu的状态</p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201129140445893.png" srcset="/img/loading.gif" alt="image-20201129140445893" style="zoom:80%;" /><ul><li>每CPU指令时钟周期，即执行一条CPU指令所消耗的CPU时钟滴答数(时钟周期)</li></ul><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201129143604453.png" srcset="/img/loading.gif" alt="image-20201129143604453" style="zoom:80%;" /><p><strong>CPU相关概念：</strong></p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201130122425880.png" srcset="/img/loading.gif" alt="image-20201130122425880" style="zoom:80%;" /><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201130122557711.png" srcset="/img/loading.gif" alt="image-20201130122557711" style="zoom:50%;" /><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201130122707919.png" srcset="/img/loading.gif" alt="image-20201130122707919" style="zoom:80%;" /><p>思考问题：</p><p>1.什么时候会发生GC？</p><p>​    GC分为两种，Minor GC与Full GC。前者清理新生代；后者通常清理整个堆，包括新生代 老年代 永久代。</p><ul><li><p>某一代满时</p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201129140930278.png" srcset="/img/loading.gif" alt="image-20201129140930278" style="zoom:80%;" /></li></ul><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201129162944023.png" srcset="/img/loading.gif" alt="image-20201129162944023" style="zoom:67%;" /><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201129163023303.png" srcset="/img/loading.gif" alt="image-20201129163023303" style="zoom:67%;" /><p>2.</p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201129140559262.png" srcset="/img/loading.gif" alt="image-20201129140559262" style="zoom:80%;" /><ol start="3"><li>多处理器和多核、逻辑 CPU 和硬件线程、超线程，以及 L1/L2/L3 三级缓存等?</li></ol><p>jstack打印的线程栈中nid就是top -Hp中pid的16进制</p><p>Tool（openjdk11）</p><ul><li><p>jconsole</p><p>使用方式：</p><ol><li><p>在java目录下与bin同级的conf目录下的management目录有文件：</p><p><a href="https://blog.csdn.net/weixin_34248023/article/details/88741423" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34248023/article/details/88741423</a></p><p><a href="https://blog.csdn.net/u013274055/article/details/83055749" target="_blank" rel="noopener">https://blog.csdn.net/u013274055/article/details/83055749</a></p><p>notion中也有记录</p></li></ol></li><li><p>jvisualvm</p></li><li><p>Jprofiler</p></li></ul><p>参考链接<a href="https://segmentfault.com/a/1190000016400305?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016400305?utm_source=tag-newest</a></p><p><strong>参考书目：</strong></p><p>《Java性能优化权威指南》</p><p>《性能工程高手课》</p><p>《Linux性能优化实战》</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>so链接存储</title>
    <link href="/2020/11/25/so%E9%93%BE%E6%8E%A5%E5%AD%98%E5%82%A8/"/>
    <url>/2020/11/25/so%E9%93%BE%E6%8E%A5%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux共享库so的组织"><a href="#Linux共享库so的组织" class="headerlink" title="Linux共享库so的组织"></a>Linux共享库so的组织</h2><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201125163543066.png" srcset="/img/loading.gif" alt="image-20201125163543066" style="zoom:67%;" /><p>目标文件如何被链接器链接到一起，形成可执行文件；可执行文件如何被装载并且执行</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>性能调优中CPU IO 网络等概念</title>
    <link href="/2020/11/24/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%ADCPU%20IO%20%E7%BD%91%E7%BB%9C%E7%AD%89%E6%A6%82%E5%BF%B5/"/>
    <url>/2020/11/24/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%ADCPU%20IO%20%E7%BD%91%E7%BB%9C%E7%AD%89%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>CPU性能受以下几个因素影响：</p><ul><li>处理器个数；</li><li>核心个数；</li><li>主频；</li><li>有无Turbo模式；</li></ul><p>虽然 CPU 更新换代，但是处理器的时钟主频基本不再提高，甚至变得更低了。这样的目的是降低 CPU 的功耗。比如 SandyBridge 的时钟频率是 2.6GHz，但是到了 Skylake，反而降低到了 2GHz。</p><p>每个处理器里面的核数却越来越多，这样就可以尽量的提升并行处理能力。</p><p>每一代 CPU 都允许 Turbo 模式，就是让 CPU 的主频提高。目的是可以让处理器在特殊情况下，用提高功耗的代价来增加主频，从而获得更高性能。</p><ul><li>如何识别运行效率高或低的应用程序？</li></ul><p>衡量一个应用程序对 CPU 使用效率时，往往会考察 CPI（Cycles Per Instruction，每指令的周期数）和 IPC（Instructions Per Cycle，每周期的指令数）。这两个指标有助于识别运行效率高或低的应用程序。</p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201126193745859.png" srcset="/img/loading.gif" alt="image-20201126193745859" style="zoom:80%;" /><ul><li>如何识别CPU性能？</li></ul><p>一台计算机的 CPU 性能一般用 MIPS（Millions ofInstructions Per Second）来衡量，表示每秒能运行多少个百万指令，MIPS 越高，性能越高。MIPS 的计算很简单，就是时钟频率×IPC。</p><p>各个核的上下文切换次数最好要均衡：</p><p>CPU 常见的各种中断包括软中断和硬中断。除此之外，还有一种特殊的中断：上下文切换。这些指标需要和每个核挂钩，理想情况下是各个核上的中断能够均衡。如果数量不均衡，往往会造成严重的性能问题——有的核会超载而导致系统响应缓慢，但是其他的核反而空闲</p><p>CPU 对多线程的执行顺序是谁定的呢？</p><p>是由内核的进程调度来决定的。内核进程调度负责管理和分配 CPU 资源，合理决定哪个进程该使用 CPU，哪个进程该等待。<strong>进程调度给不同的线程和任务分配了不同的优先级</strong>，<strong>优先级最高的是硬件中断，其次是内核（系统）进程，最后是用户进程</strong>。<strong>每个逻辑 CPU 都维护着一个可运行队列</strong>，用来存放可运行的线程来调度</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>issue contribute</title>
    <link href="/2020/11/19/issue%20contribute/"/>
    <url>/2020/11/19/issue%20contribute/</url>
    
    <content type="html"><![CDATA[<p>1.fork代码，并拉到本地创建一个分支</p><p>2.去jira找感兴趣的unassigned的issue</p><p>3.修改完后的commit msg中前面填写jira的编号，如[IOTDB-993]</p><p>![image-20201119223845591](/Users/weizihan/Library/Application Support/typora-user-images/image-20201119223845591.png)</p><p>![image-20201119224115205](/Users/weizihan/Library/Application Support/typora-user-images/image-20201119224115205.png)</p><p>[IOTDB-993][docs]</p><p>4.push到私有仓库</p><p>5.进行pull request</p><p>[docs]: </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>时序数据库</title>
    <link href="/2020/11/18/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2020/11/18/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="疑问："><a href="#疑问：" class="headerlink" title="疑问："></a>疑问：</h1><ol><li><p>WAL作用？</p></li><li><p>LSM Tree</p></li></ol><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>若往root.a.b.c(timestamp, age)插入数据，则会创建root.a存储组</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><code>IoTDB</code> 模块主要分为<code>Client</code>，<code>JDBC</code>，<code>Server</code>，<code>TsFile</code>，<code>Grafana</code>，<code>Distribution</code> 以及各种生态的<strong>连接器</strong></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>![image-20201118115504957](/Users/weizihan/Library/Application Support/typora-user-images/image-20201118115504957.png)</p><ul><li>时间序列：时间序列可以被看作产生时序数据的<strong>传感器的所在完整路径</strong>，在IoTDB中所有的时间序列必须以root开始、以传感器作为结尾。一个时间序列也可称为<strong>一个全路径</strong>。</li></ul><p>storage group只是</p><p>疑问：</p><p>当前IoTDB支持的时间序列必须大于等于四层（之后会更改为两层）？出于什么考虑？</p><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>设备-&gt;测点</p><p>device -&gt; sensor</p><p>ChunkGroupWriter-&gt;ChunkWriter</p><p>ChunkGroup-&gt;Chunk</p><p>每个设备对应一个 device，每个测点对应一个 sensor。</p><p>每个设备对应一个 ChunkGroup，每个测点对应一个 Chunk。</p><p>每个设备对应一个 ChunkGroupWriter，每个测点对应一个 ChunkWriter。</p><p><strong>一个 <code>Page</code> 页存储了 <code>Chunk</code> 的一些数据</strong></p><p>![image-20201125174419477](/Users/weizihan/Library/Application Support/typora-user-images/image-20201125174419477.png)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>linux</title>
    <link href="/2020/11/13/linux/"/>
    <url>/2020/11/13/linux/</url>
    
    <content type="html"><![CDATA[<h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>文件描述符指代<strong>打开的文件</strong></p><p>shell启动的进程会继承3个已经打开的file descriptor</p><p>0为标准输入，表示的是<strong>为进程提供</strong>输入的文件；</p><p>1为标准输出，表示的是为进程提供输出的文件；</p><p>2为标准错误，表示的是供进程写入错误或异常消息的文件；</p><p>0，1，2都是指向终端；对应stdio函数库的stdin, stdout, stderr</p><h4 id="特权进程"><a href="#特权进程" class="headerlink" title="特权进程"></a>特权进程</h4><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201113114258040.png" srcset="/img/loading.gif" alt="image-20201113114258040" style="zoom:80%;" /><p>init进程（进程号为1的进程）</p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201113115138429.png" srcset="/img/loading.gif" alt="image-20201113115138429" style="zoom:67%;" />]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2020/02/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/02/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例类只有一个私有的构造函数，这样就不能在外部使用new来实例化它。只能通过调用公共静态方法来获取其实例。</p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>参考资料：<a href="https://github.com/biezhi/java-bible/blob/master/designpatterns/strategy.md" target="_blank" rel="noopener">https://github.com/biezhi/java-bible/blob/master/designpatterns/strategy.md</a></p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>参考资料：<a href="https://blog.csdn.net/zuoxiaolong8810/article/details/9026775" target="_blank" rel="noopener">https://blog.csdn.net/zuoxiaolong8810/article/details/9026775</a></p><p><a href="https://github.com/biezhi/java-bible/blob/master/designpatterns/proxy.md" target="_blank" rel="noopener">https://github.com/biezhi/java-bible/blob/master/designpatterns/proxy.md</a></p><h1 id="Design-Pattern"><a href="#Design-Pattern" class="headerlink" title="Design Pattern"></a>Design Pattern</h1><h2 id="Strategy-Pattern"><a href="#Strategy-Pattern" class="headerlink" title="Strategy Pattern"></a>Strategy Pattern</h2><p>references: <a href="https://github.com/biezhi/java-bible/blob/master/designpatterns/strategy.md" target="_blank" rel="noopener">https://github.com/biezhi/java-bible/blob/master/designpatterns/strategy.md</a></p><h2 id="Proxy-Pattern"><a href="#Proxy-Pattern" class="headerlink" title="Proxy Pattern"></a>Proxy Pattern</h2><p>references: <a href="https://blog.csdn.net/zuoxiaolong8810/article/details/9026775" target="_blank" rel="noopener">https://blog.csdn.net/zuoxiaolong8810/article/details/9026775</a></p><p><a href="https://github.com/biezhi/java-bible/blob/master/designpatterns/proxy.md" target="_blank" rel="noopener">https://github.com/biezhi/java-bible/blob/master/designpatterns/proxy.md</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>事务管理</title>
    <link href="/2020/02/12/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    <url>/2020/02/12/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201107204053580.png" srcset="/img/loading.gif" alt="image-20201107204053580" style="zoom:67%;" /><p>在高并发场景下，若隔离没有控制得当，则可能产生：</p><p>脏读；不可重复读；幻读</p><p><strong>脏读：</strong></p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201107204144410.png" srcset="/img/loading.gif" alt="image-20201107204144410" style="zoom:50%;" /><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201107203810855.png" srcset="/img/loading.gif" alt="image-20201107203810855" style="zoom:67%;" /><p>开启事务（关闭自动提交事务）</p><p>提交事务</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal</title>
    <link href="/2020/02/05/ThreadLocal/"/>
    <url>/2020/02/05/ThreadLocal/</url>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal在JDBC-Connection场景中使用案列"><a href="#ThreadLocal在JDBC-Connection场景中使用案列" class="headerlink" title="ThreadLocal在JDBC Connection场景中使用案列"></a>ThreadLocal在JDBC Connection场景中使用案列</h2><p>使用ThreadLocal保存JDBC链接</p><p><strong>数据库连接工具类：</strong></p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201107195011934.png" srcset="/img/loading.gif" alt="image-20201107195011934" style="zoom:57%;" /><p>数据库链接的使用方式：</p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201107195147652.png" srcset="/img/loading.gif" alt="image-20201107195147652" style="zoom:57%;" /><p>这个数据库链接使用的方式在多线程下会报<strong>数据库连接关闭错误</strong>。因为这个连接在多线程下是共用的，可能线程1 close了，线程2还在用相同的连接。（<strong>疑问：</strong>DriverManager.getConnection返回的是同一个对象吗？否则多线程返回的应该互不相干啊？答：多线程出现的场景可能是这样的：假设有线程A与线程B，线程A执行完conn=DriverManager.getConnection后，线程B执行conn=DriverManager.getConnection后，又由于conn是static的，所以当线程A执行conn.close时，实际上是线程B的conn，因此，若此时线程B还在执行，则会报错）</p><p>使用ThreadLocal来保护连接（因为Connection是static变量才用ThreadLocal；又或者可以直接将Connection不设为static变量，这样就不会线程不安全）</p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201107201630166.png" srcset="/img/loading.gif" alt="image-20201107201630166" style="zoom:50%;" /><p>参考文献: 架构探险 从零开始写javaweb框架</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JMM</title>
    <link href="/2020/02/02/JMM/"/>
    <url>/2020/02/02/JMM/</url>
    
    <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>重排序与happens-before的关系是什么？</p><p>在重排序的基础上，JMM为了保证：</p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201101235436070.png" srcset="/img/loading.gif" alt="image-20201101235436070" style="zoom:67%;" /><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201101173100615.png" srcset="/img/loading.gif" alt="image-20201101173100615" style="zoom:67%;" /><p>​        编译器（代码重排序）与处理器（指令重排序）不会改变存在<strong>数据依赖关系</strong>的两个操作的执行顺序。</p><p>​        这里所说的<strong>数据依赖关系</strong>仅针对<strong>单个处理器</strong>中执行的指令序列和<strong>单个线程</strong>中执行的操作，<strong>不同处理器之间和不同线程</strong>之间的数据依赖关系<strong>不被编译器和处理器考虑</strong>。如：</p><p><code>sfafasfsdf</code></p><h2 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h2><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JAVA8</title>
    <link href="/2020/01/21/java8/"/>
    <url>/2020/01/21/java8/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA知识点"><a href="#JAVA知识点" class="headerlink" title="JAVA知识点"></a>JAVA知识点</h1><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201101155547162.png" srcset="/img/loading.gif" alt="image-20201101155547162" style="zoom:55%;" /><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201101155651257.png" srcset="/img/loading.gif" alt="image-20201101155651257" style="zoom:50%;" /></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>由上面两张图可知，Thread的构造函数的参数是函数式接口，调用方式可以是如下的任意一种：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">//注意，Runnable 的抽象函数的参数为空，因此传入的 getValue() setValue()函数的参数都为空</span>    <span class="hljs-keyword">new</span> Thread(() -&gt; setValue()).start();    <span class="hljs-keyword">new</span> Thread(Main::getValue).start();    <span class="hljs-comment">//注意 printAge(10) 这种形式的函数的传入</span>    <span class="hljs-keyword">new</span> Thread(() -&gt; printAge(<span class="hljs-number">10</span>)).start();&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> age = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">()</span> </span>&#123;    age = <span class="hljs-number">10</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(age);    <span class="hljs-keyword">return</span> age;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;    System.out.println(age);&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">happensBefore</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> b = a + <span class="hljs-number">1</span>;    System.out.println(b);&#125;</code></pre><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/147719155" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/147719155</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>重构</title>
    <link href="/2020/01/18/%E9%87%8D%E6%9E%84/"/>
    <url>/2020/01/18/%E9%87%8D%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="重构的目的"><a href="#重构的目的" class="headerlink" title="重构的目的"></a>重构的目的</h1><ul><li>使程序易于维护<ul><li>bug修复</li><li>特性增加</li></ul></li><li>若项目代码已经很凌乱或满是错误，则重构不如重写。</li></ul><h2 id="步骤一：构建一致性验证体系"><a href="#步骤一：构建一致性验证体系" class="headerlink" title="步骤一：构建一致性验证体系"></a>步骤一：构建一致性验证体系</h2><p>每次进行少量代码的重构，并在重构后进行一致性验证</p><img src="/Users/weizihan/Library/Application Support/typora-user-images/image-20201101113938245.png" srcset="/img/loading.gif" alt="image-20201101113938245" style="zoom:67%;" /><h2 id="步骤二：重构"><a href="#步骤二：重构" class="headerlink" title="步骤二：重构"></a>步骤二：重构</h2><ul><li>函数表达的是一个功能，而此功能应隶属于某个类。因此，应尽可能将函数放置本属于它的类中，即放对位置</li></ul><p>看到3.6节</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>开篇</title>
    <link href="/2020/01/12/%E5%BC%80%E7%AF%87/"/>
    <url>/2020/01/12/%E5%BC%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="开篇——过往知识的总结"><a href="#开篇——过往知识的总结" class="headerlink" title="开篇——过往知识的总结"></a>开篇——过往知识的总结</h1><h2 id="为什么要对之前的知识进行总结？"><a href="#为什么要对之前的知识进行总结？" class="headerlink" title="为什么要对之前的知识进行总结？"></a>为什么要对之前的知识进行总结？</h2><p>​        目前很多笔记较为零散。<em>在形式上</em>，笔记内容散落于onenote 有道笔记 线下笔记簿 手机笔记簿 等各处；<em>在内容上</em>，许多同类知识点未能从点串连成线，形成更为系统的知识框架。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h2><h3 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h3><ul><li>重构</li><li>设计模式</li></ul><h2 id="思维"><a href="#思维" class="headerlink" title="思维"></a>思维</h2><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
